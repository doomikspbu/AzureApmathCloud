@{
    public delegate double func(double a);
    public struct FuncInf
    {
    	public string Name; 
        public char ShortName;
        public func f;
        public FuncInf(string n, char s, func fu)
        {
            Name = n;
            ShortName = s;
            f = fu;
        }
    }
    
    public class InfixToPostfix
    {
        public string Postfix
        {
            get;
            protected set;
        }
        private int L;
        private double[] param = new double[23];
        private byte ParIndex = 0;
        static private FuncInf[] FTable = 
        {
    	    new FuncInf("arcsin", 'á', Math.Asin),
	        new FuncInf("arccos", 'â', Math.Acos),
    	    new FuncInf("sin", 'ã', Math.Sin),
    	    new FuncInf("cos", 'ä', Math.Cos),
            new FuncInf("sqrt", 'å', Math.Sqrt),
        	new FuncInf("arctg", 'æ', Math.Atan),
	        new FuncInf("tg", 'ç', Math.Tan),
        	new FuncInf("ln", 'è', Math.Log),
	        new FuncInf("exp", 'ê', Math.Exp),
    	    new FuncInf("abs", 'ë', Math.Abs),
    	    new FuncInf("sinh", 'ì', Math.Sinh),
	        new FuncInf("cosh", 'í', Math.Cosh)
        };
        static public byte[,] ActionsTable = {
           //0  +  -  *  /  (  )  F  P  ^
	        {4, 1, 1, 1, 1, 1, 5, 1, 6, 1}, // 0
	        {2, 2, 2, 1, 1, 1, 2, 1, 6, 1}, // +
	        {2, 2, 2, 1, 1, 1, 2, 1, 6, 1}, // - 
	        {2, 2, 2, 2, 2, 1, 2, 1, 6, 1}, // * 
    	    {2, 2, 2, 2, 2, 1, 2, 1, 6, 1}, // /
	        {5, 1, 1, 1, 1, 1, 3, 1, 6, 1}, // (
	        {2, 2, 2, 2, 2, 1, 2, 7, 6, 2}, //F
    	    {2, 2, 2, 2, 2, 1, 2, 1, 6, 2}	//^
        };
        private static int sizeFTable = FTable.Length;
        public InfixToPostfix (string input)
        {
            string filter = InfixFilter(input);
            Postfix = Infix2Postfix(filter);
        }
        
        public static int FunNumberByShortName (char s)
        {
	        for (int i=0; i<sizeFTable; ++i)
		        if (FTable[i].ShortName == s) return i;
            throw new System.ArgumentException("FunNumberByShortName Error!!", "original");
        }
        public static int FunNumberByName (string s)
        {
	        for (int i=0; i<sizeFTable; ++i)
		        if (FTable[i].Name == s) return i;
            throw new System.ArgumentException("FunNumberByName Error!!", "original");
        }
        public static int RowNumber(char ch)
        {
	        switch(ch)
	        {
    	        case (char)0: return 0;
	            case '+': return 1;
	            case '-': return 2;
	            case '*': return 3;
    	        case '/': return 4;
	            case '(': return 5;
	            case '^': return 7;
	            default: return 6;
	        }
            throw new System.ArgumentException("InfixError (RowNumber)!!!", "original");
        }

        public static int ColNumber(char ch)
        {
	        switch(ch)
	        {
	            case (char)0: return 0;
	            case '+': return 1;
            	case '-': return 2;
	            case '*': return 3;
	            case '/': return 4;
	            case '(': return 5;
	            case ')': return 6;
	            case '^': return 9;
	        }
	        if(ch >= 'a' && ch <= 'z') return 8;
	        if(ch >= 'A' && ch <= 'Z') return 8;
	        if(ch >= '0' && ch <= '9') return 8;
	        return 7;
            throw new System.ArgumentException("InfixError (ColNumber)!!!", "original");
}
        private string InfixFilter (string instr)
        {
            string outstr = "";
	        int i=0, j=0;
            char ch;
            char prev = (char)0;
	        string buf = ""; 
            //int buflen=0;
            int instrLen = instr.Length;

            while (i != instrLen)
	        {
                ch = (char)(instr[i++]);
		        if (ch == ' ') continue;
                if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '.')
                {
                    buf += ch;
                }
                else
                {
                    if (buf.Length!= 0 && (buf[0]<='9' && buf[0]>='0'))
                    { 
                        bool err = false, point = false;
                        double tmp = 0;
                        for (int k = 0, cnt = 0; k < buf.Length; ++k)
                        {
                            if (!(buf[k] <= '9' && buf[k] >= '0' || buf[k] == '.'))
                            {
                                err = true;
                                break;
                            }
                            if (buf[k] == '.')
                            {
                                point = true;
                                continue;
                            }
                            if (!point)
                            {
                                tmp = tmp * Math.Pow(10, cnt) + (buf[k] - '0');
                                ++cnt;
                            }
                            else
                            {
                                tmp += (buf[k] - '0') * Math.Pow(10, -k + cnt);
                            }
                        }
                        if (ParIndex >= 23) throw new System.ArgumentException("InfixFilterError!!! Too many parameters (<=23)");
                        param[ParIndex] = tmp;
                        outstr += ((char)((ParIndex) + (byte)'a')).ToString();
                        buf = "";
                        ++ParIndex;
                        
                        if (err) throw new System.ArgumentException("InfixFilterError!!!");
                    }
                    
                    if (ch == '-' && (prev == 0 || prev == '(') && buf.Length == 0)
                    {
                        outstr += '0';
                        //continue;
                    }

                    if (buf.Length == 1)
                    {
                        
                        if (buf == "x") buf = "X";
                        outstr += buf; buf = "";
                    }
                    else if (buf.Length > 1)
                    {
                        if (buf[0] <= '9' && buf[0] >= '0')
                        {
                            if (ParIndex >= 23) throw new System.ArgumentException("InfixFilterError!!! Too many parameters (<=23)");
                            param[ParIndex] = buf[0] - '0';
                            buf = ((char)((ParIndex) + (byte)'a')).ToString();
                            ++ParIndex;
                        }
                        else
                        {
                            //buf[buflen] = '\0';
                            outstr += FTable[FunNumberByName(buf)].ShortName;
                            buf = "";
                        }
                        //outstr += buf; buf = "";
                    }
                    outstr += ch;
                }
		        prev=ch;
	        }
            if (buf.Length > 1)
            {
                bool err = false;
                bool point = false;
                double tmp = 0;
                for (int k = 0, cnt = 0; k < buf.Length; ++k)
                {
                    if (!(buf[k] <= '9' && buf[k] >= '0' || buf[k] == '.'))
                    {
                        err = true;
                        break;
                    }
                    if (buf[k] == '.')
                    {
                        point = true;
                        continue;
                    }
                    if (!point)
                    {
                        tmp = tmp * Math.Pow(10, cnt) + (buf[k] - '0');
                        ++cnt;
                    }else
                    {
                        tmp += (buf[k] - '0') * Math.Pow(10, -k+cnt);
                    }
                }
                if(ParIndex >= 23) throw new System.ArgumentException("InfixFilterError!!! Too many parameters (<=23)");
                param[ParIndex] = tmp;
                buf = ((char)((ParIndex) + (byte)'a')).ToString();
                ++ParIndex;
                
                if (err) throw new System.ArgumentException("InfixFilterError!!!", "original");
            }
            if (buf.Length > 0)
            {
                if (buf[0] <= '9' && buf[0] >= '0')
                {
                    if (ParIndex >= 23) throw new System.ArgumentException("InfixFilterError!!! Too many parameters (<=23)");
                    param[ParIndex] = buf[0] - '0';
                    buf = ((char)((ParIndex) + (byte)'a')).ToString();
                    ++ParIndex;
                }
                else
                    if (buf == "x") buf = "X";
                outstr += buf;

            }
	        //outstr[j++]='\0';
            return outstr;
        }
        public static string Infix2Postfix(string instr)
        {
            string outstr = "";
	        int i = 0, j = 0;
	        int row, col;
	        byte action;
	        Stack S = new Stack();
	        do
	        {
		        col = instr.Length != i ? ColNumber(instr[i]):0;
		        if(S.Count == 0) 
			        row = 0; 
		        else 
			        row = RowNumber((char)S.Peek());
		        action = ActionsTable[row,col];
		        switch(action)
    		    {
	    	        case 1: S.Push(instr[i]); ++i; break;
		            case 2: outstr += (char)S.Pop();  break;
    		        case 3: S.Pop(); ++i; break;
	    	        case 4: break;
                    case 5: throw new System.ArgumentException("Error with brackets in \"" + instr + "\" at " + instr[i], "original"); break;
    		        case 6: outstr += instr[i++]; break;
                    case 7: throw new System.ArgumentException("Error with brackets after or before function in\"" + instr + "\" at " + instr[i], "original"); break;
		        }
	        }while(action != 4);
            return outstr;
        }
        public double Calc(double x)
        {
            L = Postfix.Length;
            return CalculateByPosfix(x);
        }
        private double CalculateByPosfix(double x)
        {
            string s = Postfix.Substring(0, L);
            --L;
            if (s[L] <= 'z' && s[L] >= 'a')
            {
                return param[(byte)(s[L] - 'a')];
            }
            if (s[L] <= 'í' && s[L] >= 'á')
            {
                return FTable[FunNumberByShortName(s[L])].f(CalculateByPosfix(x));
            }
            if (s[L] == '0')
                return 0.0;
            if (s[L] == '1')
                return 1.0;
            if (s[L] == 'X')
                return x;
            double a, b;
            switch (s[L])
            {
                case '+': 
                    b = CalculateByPosfix(x);
                    a = CalculateByPosfix(x);
                    return a + b;
                case '-': 
                    b = CalculateByPosfix(x);
                    a = CalculateByPosfix(x);
                    return a - b;
                case '*': 
                   b = CalculateByPosfix(x);
                   a = CalculateByPosfix(x);
                   return a * b;
                case '/': 
                    b = CalculateByPosfix(x);
                    a = CalculateByPosfix(x);
                    if (b == 0.0) throw new System.ArgumentException("Divide by zero!!!");
                    return a / b;
                case '^': 
                    b = CalculateByPosfix(x);
                    a = CalculateByPosfix(x);
                    return Math.Pow(a, b);
                default: throw new System.ArgumentException("Calculate error!!!");
            }
        }
        int Ldiff;
        public string diff(string inposfix)
        {
            Ldiff = inposfix.Length;
            return diffPosfix(inposfix);
        }
        private string expr (string s)
        {
            --Ldiff;
            char ch = s[Ldiff];
            if ((ch<='z' && ch>='a') || ch == '0' || ch == '1' || ch == 'X')
            {
                return ch.ToString();
            }
            if (ch <= 'í' && ch >= 'á')
                return expr(s) + ch;
            else 
            {
                string b = expr(s);
                string a = expr(s);
                return a + b + ch;
            }
                
        }
        private string diffPosfix(string inposfix)
        {
            string s = inposfix.Substring(0, Ldiff);
            --Ldiff;
            string a, b, r;
            int tmp;
            if (s[Ldiff] == 'X')
                return "1";
            if (((byte)s[Ldiff] <= (byte)'z' && (byte)s[Ldiff] >= (byte)'a') || s[Ldiff] == '1' || s[Ldiff] == '0')
                return "0";
            switch (s[Ldiff])
            {
                case '+':
                    b = expr(s.Substring(0, Ldiff));
                    a = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(a) + diff(b) + '+';
                    Ldiff = tmp;
                    return r;
                case '-':
                    b = expr(s.Substring(0, Ldiff));
                    a = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(a) + diff(b) + '-';
                    Ldiff = tmp;
                    return r;
                case '*':
                    b = expr(s.Substring(0, Ldiff));
                    a = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r =  diff(a) + b + '*' + a + diff(b) + '*' + '+';
                    Ldiff = tmp;
                    return r;
                case '/':
                    b = expr(s.Substring(0, Ldiff));
                    a = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(a) + b + '*' + a + diff(b) + '*' + '-' + b + b + '*' + '/';
                    Ldiff = tmp;
                    return r;
                case 'á':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + '1' + b + "2^-å/";
                    Ldiff = tmp;
                    return r;
                case 'â':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = '0'+diff(b) + '1' + b + "2^-å/-";
                    Ldiff = tmp;
                    return r;
                case 'ã':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + "ä*";
                    Ldiff = tmp;
                    return r;
                case 'ä':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = '0' + diff(b) + b + "ã*-";
                    Ldiff = tmp;
                    return r;
                case 'e':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + 'å' + b + "å+/";
                    Ldiff = tmp;
                    return r;
                case 'æ':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + '1' + b + b + "*+/";
                    Ldiff = tmp;
                    return r;
                case 'ç':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + 'ä' + b + "ä*/";
                    Ldiff = tmp;
                    return r;
                case 'è':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + "/";
                    Ldiff = tmp;
                    return r;
                case 'ê':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + "ê*";
                    Ldiff = tmp;
                    return r;
                case 'ì':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + "í*";
                    Ldiff = tmp;
                    return r;
                case 'í':
                    b = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = diff(b) + b + "ì*";
                    Ldiff = tmp;
                    return r;
                case '^':
                    b = expr(s.Substring(0, Ldiff));
                    a = expr(s.Substring(0, Ldiff));
                    tmp = Ldiff;
                    r = "b" + diff(a) + a + b + "1-^**";
                    Ldiff = tmp;
                    return r;
                default:
                    throw new System.ArgumentException("Cannot diff!!! " + s[Ldiff].ToString());
            }
        }
        public string diffnPost(string inp, int n)
        {
            if (n == 0) return inp;
            string tmp = inp;
            for (int i=0; i<n; ++i)
                tmp = diff(tmp);
            return tmp;
        }
        public double diffn(string inp, double x, int n)
        {
            string tmp = Postfix;
            Postfix = diffnPost(inp, n);
            double res = Calc(x);
            Postfix = tmp;
            return res;
        }
    }

    
}

<html>
<head>
    <script type="text/javascript"
            src="https://www.google.com/jsapi?autoload={
            'modules':[{
              'name':'visualization',
              'version':'1',
              'packages':['corechart']
            }]
          }"></script>

    <script type="text/javascript">
        google.setOnLoadCallback(drawChart);

        function drawChart() {
            var data = google.visualization.arrayToDataTable([
              ['Year', 'Sales', 'Expenses'],
              ['2004', 1000, 400],
              ['2005', 1170, 460],
              ['2006', 660, 1120],
              ['2007', 1030, 540]
            ]);

            var options = {
                title: 'Company Performance',
                curveType: 'function',
                legend: { position: 'bottom' }
            };

            var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));

            chart.draw(data, options);
        }
    </script>
</head>
<body>
    <div id="curve_chart" style="width: 900px; height: 500px"></div>
</body>
</html>